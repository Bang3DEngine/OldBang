#include "G.frag_g"

uniform vec2  B_fontAtlasSize;

uniform bool  B_usingDistField;

uniform float B_textBlurriness;
uniform float B_textAlphaThreshold;

uniform float B_outlineWidth;
uniform vec4  B_outlineColor;
uniform float B_outlineBlurriness;

void Main()
{
    vec2 charAtlasUv = B_FragIn_Uv;
    vec4 thisColor = texture2D(B_Texture0, charAtlasUv);
    if (B_usingDistField)
    {
        float dist = thisColor.r;

        float lowerCharLimit = B_textAlphaThreshold - B_textBlurriness;
        if (dist <= lowerCharLimit)
        {
            B_Out_Color = vec4(vec3(1), 1.0f); // Just opaque character
        }
        else
        {
            // Outside opaque character zone

            float upperCharLimit = B_textAlphaThreshold + B_textBlurriness;
            if (B_outlineWidth > 0)
            {
                // Outline zone
                float outlineBlur  = B_outlineBlurriness;
                float outlineLimit = B_textAlphaThreshold + B_outlineWidth;
                float outlineLowerLimit = outlineLimit - outlineBlur;
                float outlineUpperLimit = outlineLimit + outlineBlur;

                if (dist > outlineUpperLimit) { discard; }

                float outlineAlpha = 1.0f - smoothstep(outlineLowerLimit,
                                                       outlineUpperLimit,
                                                       dist);
                B_Out_Color = vec4(B_outlineColor.rgb,
                                   B_outlineColor.a * outlineAlpha);


                if (dist <= upperCharLimit)
                {
                    // Blend outline color with character color
                    float charAlpha = 1.0f-smoothstep(lowerCharLimit, upperCharLimit, dist);
                    vec4 charColor = vec4(vec3(1), charAlpha);
                    B_Out_Color = vec4(mix(B_Out_Color.rgb, charColor.rgb, charAlpha),
                                       max(charAlpha, outlineAlpha));
                }
            }
            else
            {
                // No outline, but character has smoothstep alpha
                if (dist > upperCharLimit) { discard; }

                float charAlpha = 1.0f-smoothstep(lowerCharLimit, upperCharLimit, dist);
                B_Out_Color = vec4(vec3(1), charAlpha);
            }
        }
    }
    else
    {
        B_Out_Color = vec4(1, 1, 1, thisColor.a);
    }
}
